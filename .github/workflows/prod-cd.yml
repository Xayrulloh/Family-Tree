name: Production Deployment

on:
  push:
    branches:
      - main
    paths:
      - 'apps/api/**'
      - 'libs/shared/**'
      - 'package.json'
      - 'pnpm-lock.yaml'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}-api
  ENVIRONMENT: production
  ENV_SLUG: prod
  IMAGE_TAG: latest
  DEPLOY_PATH: /opt/family-tree/production

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile --prefer-offline --ignore-scripts

      - name: Build API
        run: npx nx build api --prod

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ env.IMAGE_TAG }}
            type=raw,value=prod-${{ github.sha }}
            type=raw,value=prod-{{date 'YYYYMMDD-HHmmss'}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NODE_ENV=production
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

      - name: Prepare deployment files
        run: |
          mkdir -p deploy
          cp apps/api/docker-compose.yml deploy/
          
          cat > deploy/.env.deploy << EOF
          ENV=production
          NODE_ENV=production
          DOCKER_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          API_PORT=3000
          EOF

      - name: Transfer deployment files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.KEY }}
          source: "deploy/*"
          target: ${{ env.DEPLOY_PATH }}
          strip_components: 1
          overwrite: true

      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.0.3
        env:
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
          ENV_SLUG: ${{ env.ENV_SLUG }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          DOCKER_IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          REGISTRY: ${{ env.REGISTRY }}
          INFISICAL_CLIENT_ID: ${{ secrets.INFISICAL_CLIENT_ID }}
          INFISICAL_CLIENT_SECRET: ${{ secrets.INFISICAL_CLIENT_SECRET }}
          INFISICAL_PROJECT_ID: ${{ secrets.INFISICAL_PROJECT_ID }}
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.KEY }}
          envs: DEPLOY_PATH,ENV_SLUG,ENVIRONMENT,DOCKER_IMAGE,REGISTRY,INFISICAL_CLIENT_ID,INFISICAL_CLIENT_SECRET,INFISICAL_PROJECT_ID
          script: |
            set -e
            
            echo "ğŸš€ Starting PRODUCTION deployment..."
            
            # Create deployment directory if it doesn't exist
            echo "ğŸ“ Ensuring deployment directory exists..."
            sudo mkdir -p $DEPLOY_PATH
            sudo chown -R $USER:$USER $DEPLOY_PATH
            cd $DEPLOY_PATH
            
            # Log in to GitHub Container Registry
            echo "ğŸ” Logging in to GitHub Container Registry..."
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login $REGISTRY -u ${{ github.actor }} --password-stdin
            
            # Install Infisical CLI if not exists
            if ! command -v infisical &> /dev/null; then
              echo "ğŸ“¥ Installing Infisical CLI..."
              curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
              sudo apt-get update && sudo apt-get install -y infisical
            fi
            
            # Authenticate with Infisical
            echo "ğŸ”‘ Authenticating with Infisical..."
            export INFISICAL_TOKEN=$(infisical login \
              --method=universal-auth \
              --client-id=$INFISICAL_CLIENT_ID \
              --client-secret=$INFISICAL_CLIENT_SECRET \
              --plain \
              --silent)
            
            # Export secrets from Infisical
            echo "ğŸ“¥ Fetching secrets from Infisical (prod environment)..."
            infisical export \
              --env=$ENV_SLUG \
              --projectId=$INFISICAL_PROJECT_ID \
              --format=dotenv > .env.secrets
            
            # Merge deployment env with secrets
            echo "ğŸ”§ Merging environment variables..."
            cat .env.deploy .env.secrets > .env
            
            # Pull latest image
            echo "ğŸ“¦ Pulling Docker image: $DOCKER_IMAGE..."
            docker pull $DOCKER_IMAGE
            
            # Stop existing containers
            echo "ğŸ”„ Stopping existing containers..."
            docker compose down || true
            
            # Clean up old images (keep last 3)
            echo "ğŸ§¹ Cleaning up old images..."
            docker images | grep family-tree-api | tail -n +4 | awk '{print $3}' | xargs -r docker rmi || true
            docker image prune -f
            
            # Start services
            echo "ğŸš€ Starting services with docker compose..."
            docker compose up -d --remove-orphans
            
            # Wait for containers to be healthy
            echo "â³ Waiting for services to be healthy..."
            timeout=60
            elapsed=0
            while [ $elapsed -lt $timeout ]; do
              if docker compose ps | grep -q "healthy\|running"; then
                break
              fi
              sleep 2
              elapsed=$((elapsed + 2))
            done
            
            # Show status
            echo ""
            echo "âœ… PRODUCTION deployment completed!"
            echo ""
            echo "ğŸ“Š Container status:"
            docker compose ps
            echo ""
            echo "ğŸ“ Recent API logs:"
            docker compose logs --tail=30 api
            echo ""
            echo "ğŸŒ API should be available at: http://$(curl -s ifconfig.me):3000"
            
            # Cleanup sensitive files
            echo "ğŸ§¹ Cleaning up sensitive files..."
            rm -f .env.secrets .env.deploy
            
            # Logout from registry
            docker logout $REGISTRY
            
            echo ""
            echo "ğŸ‰ Production deployment finished successfully!"